import streamlit as st
import json
import random
import string
import plotly.graph_objects as go
from motor_logica import MotorJogo

# Configura√ß√£o da P√°gina
st.set_page_config(page_title="Football Bingo-Stop", layout="wide")

# Carregar Todas as T√°ticas
@st.cache_data
def load_taticas_all():
    with open("data/taticas.json", "r") as f:
        return json.load(f)

taticas = load_taticas_all()

# Inicializar Sess√£o
if "jogo_iniciado" not in st.session_state:
    st.session_state.jogo_iniciado = False
if "tatica_nome" not in st.session_state:
    st.session_state.tatica_nome = "4-3-3"
if "db_path" not in st.session_state:
    st.session_state.db_path = "data/jogadores.csv"

# Previne renderiza√ß√£o do motor antes de escolher DB
if st.session_state.jogo_iniciado:
    @st.cache_resource
    def load_motor_with_path(path):
        return MotorJogo(data_path=path)
        
    motor = load_motor_with_path(st.session_state.db_path)
    tatica_base = taticas[st.session_state.tatica_nome]

    if "pontuacao" not in st.session_state:
        st.session_state.pontuacao = 0
    if "pulos_usados" not in st.session_state:
        st.session_state.pulos_usados = 0
    if "posicoes_preenchidas" not in st.session_state:
        st.session_state.posicoes_preenchidas = {}
    if "posicao_selecionada" not in st.session_state:
        st.session_state.posicao_selecionada = tatica_base[0]['id'] if tatica_base else None

    # Pega o nome da posi√ß√£o selecionada para sortear letra v√°lida (se poss√≠vel)
    def get_pos_str(pos_id):
        for p in tatica_base:
            if p['id'] == pos_id:
                return p['posicao']
        return ""

    if "letra_atual" not in st.session_state:
        st.session_state.letra_atual = motor.sortear_letra_valida(get_pos_str(st.session_state.posicao_selecionada))

# --- FUN√á√ÉO PARA DESENHAR O CAMPO ---
def desenhar_campo(tatica):
    fig = go.Figure()

    # Desenho do Gramado
    fig.add_shape(type="rect", x0=0, y0=0, x1=100, y1=100, fillcolor="#2e7d32", line=dict(color="white", width=2))
    
    # Linha e c√≠rculo central
    fig.add_shape(type="line", x0=0, y0=50, x1=100, y1=50, line=dict(color="white", width=2))
    fig.add_shape(type="circle", x0=35, y0=40, x1=65, y1=60, line=dict(color="white", width=2))
    
    # √Årea de P√™nalti
    fig.add_shape(type="rect", x0=25, y0=0, x1=75, y1=16.5, line=dict(color="white", width=2))
    fig.add_shape(type="rect", x0=25, y0=83.5, x1=75, y1=100, line=dict(color="white", width=2))

    # Adicionando os Jogadores
    for p in tatica:
        pid = p['id']
        x = p['x']
        # No streamllit HTML o 0 era no top e 100 bottom. O Plotly tem origin no bottom-left (y=0 √© embaixo).
        # Vamos inverter o y.
        y = 100 - p['y']
        
        cor_ponto = "lightgrey"
        texto = p['posicao']
        
        if pid in st.session_state.posicoes_preenchidas:
            info = st.session_state.posicoes_preenchidas[pid]
            cat = info['categoria']
            if cat == "LENDA":
                cor_ponto = "gold"
            elif cat == "FOLCLORICO/HISTORICO":
                cor_ponto = "silver"
            else:
                cor_ponto = "white"
                
            texto = f"{p['posicao']}<br><b>{info['nome']}</b>"
            
        # Destaque para posi√ß√£o selecionada
        linha_cor = "yellow" if pid == st.session_state.posicao_selecionada else "white"
        linha_largura = 5 if pid == st.session_state.posicao_selecionada else 2
        
        fig.add_trace(go.Scatter(
            x=[x],
            y=[y],
            mode="markers+text",
            marker=dict(size=30, color=cor_ponto, line=dict(width=linha_largura, color=linha_cor)),
            text=[texto],
            textposition="bottom center",
            textfont=dict(color="white" if cor_ponto == "lightgrey" else "black", size=12),
            name=str(pid),
            hoverinfo="none",
            hoverlabel=dict(bgcolor="white", font_size=16)
        ))

    fig.update_layout(
        width=600, height=800,
        margin=dict(l=10, r=10, t=10, b=10),
        xaxis=dict(showgrid=False, zeroline=False, showticklabels=False, range=[0, 100]),
        yaxis=dict(showgrid=False, zeroline=False, showticklabels=False, range=[0, 100]),
        paper_bgcolor="rgba(0,0,0,0)",
        plot_bgcolor="rgba(0,0,0,0)",
        showlegend=False
    )
    
    return fig

st.title("‚öΩ Football Bingo-Stop")

if not st.session_state.jogo_iniciado:
    st.markdown("### Configura√ß√£o da Partida")
    st.write("Antes de entrar em campo, defina as configura√ß√µes da sua partida:")
    
    col_conf1, col_conf2 = st.columns(2)
    with col_conf1:
        st.session_state.db_path = st.selectbox(
            "Base de Dados (CSV):",
            ["data/jogadores.csv"] # Futuramente usar os.listdir('data') para listar
        )
    with col_conf2:
        st.session_state.tatica_nome = st.selectbox(
            "Forma√ß√£o T√°tica:",
            list(taticas.keys())
        )
        
    st.divider()
    if st.button("‚ñ∂Ô∏è INICIAR PARTIDA", use_container_width=True, type="primary"):
        st.session_state.jogo_iniciado = True
        st.rerun()

else:
    # Layout do Jogo
    col1, col2 = st.columns([1, 2])
    
    with col1:
        st.header("Painel de Controle")
        
        col_met1, col_met2, col_met3 = st.columns(3)
        col_met1.metric("Pontua√ß√£o Total", st.session_state.pontuacao)
        col_met2.metric("Pulos Usados", st.session_state.pulos_usados)
        
        with col_met3:
            if st.button("üîÑ Recarregar DB"):
                load_motor_with_path.clear()
                st.session_state.letra_atual = load_motor_with_path(st.session_state.db_path).sortear_letra_valida(get_pos_str(st.session_state.posicao_selecionada))
                st.rerun()
                
        st.divider()
        
        st.markdown(f"### Letra Atual: <span style='color:red; font-size:40px'>{st.session_state.letra_atual}</span>", unsafe_allow_html=True)
        
        # Nova rodada de Letra / Pulo
        if st.button("Pular Letra"):
            deducao, novos_pulos, msg = motor.processar_pulo(st.session_state.pulos_usados)
            st.session_state.pontuacao += deducao
            st.session_state.pulos_usados = novos_pulos
            st.session_state.letra_atual = motor.sortear_letra_valida(get_pos_str(st.session_state.posicao_selecionada))
            st.warning(f"Letra alterada! {msg}")
            st.rerun()
    
        st.divider()
        
        # Sele√ß√£o de Posi√ß√£o
        posicoes_disponiveis = [p for p in tatica_base if p['id'] not in st.session_state.posicoes_preenchidas]
        
        if posicoes_disponiveis:
            escolha = st.selectbox(
                "Selecione uma posi√ß√£o para preencher:",
                options=[p['id'] for p in posicoes_disponiveis],
                format_func=lambda x: f"Posi√ß√£o {x} - {get_pos_str(x)}"
            )
            
            # Se a posi√ß√£o muda, sorteamos uma nova letra v√°lida para aquela posi√ß√£o
            # caso a posi√ß√£o tenha mudado no selectbox e a letra atual n√£o seja v√°lida
            pos_str = get_pos_str(escolha)
            if st.session_state.posicao_selecionada != escolha:
                st.session_state.posicao_selecionada = escolha
                # S√≥ muda a letra se a atual n√£o tiver ngm e se mudar de ideia
                if motor.mapa_letras.empty or pos_str not in motor.mapa_letras.index or st.session_state.letra_atual not in motor.mapa_letras.columns or motor.mapa_letras.loc[pos_str, st.session_state.letra_atual] == 0:
                    st.session_state.letra_atual = motor.sortear_letra_valida(pos_str)
                    st.rerun()
            
            palpite = st.text_input("Nome do Jogador:")
            
            if st.button("Tentar Escalar"):
                if palpite:
                    valido, msg, pontos, row = motor.validar_palpite(palpite, st.session_state.letra_atual, pos_str)
                    if valido:
                        st.success(f"{msg} (+{pontos} pts)")
                        st.session_state.pontuacao += pontos
                        st.session_state.posicoes_preenchidas[escolha] = {
                            "nome": row['nome'],
                            "categoria": row['categoria']
                        }
                        
                        # Procura pr√≥xima posi√ß√£o dispon√≠vel
                        prox_posicoes = [p['id'] for p in tatica_base if p['id'] not in st.session_state.posicoes_preenchidas]
                        if prox_posicoes:
                            prox_pos = prox_posicoes[0]
                            st.session_state.posicao_selecionada = prox_pos
                            st.session_state.letra_atual = motor.sortear_letra_valida(get_pos_str(prox_pos))
                        
                        st.rerun()
                    else:
                        st.error(msg)
                else:
                    st.warning("Digite um nome!")
        else:
            st.success("üéâ T√°tica Completada! Parab√©ns!")
            
        st.divider()
        if st.button("Voltar ao Menu Principal"):
            st.session_state.jogo_iniciado = False
            for key in ["pontuacao", "pulos_usados", "posicoes_preenchidas", "posicao_selecionada", "letra_atual"]:
                if key in st.session_state:
                    del st.session_state[key]
            st.rerun()
    
    with col2:
        st.subheader(f"T√°tica em Campo ({st.session_state.tatica_nome})")
        campo_plot = desenhar_campo(tatica_base)
        st.plotly_chart(campo_plot, use_container_width=True)
